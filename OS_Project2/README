H εργασία υλοποιεί πλήρως τα ζητούμενα, με σωστά αποτελέσματα και χωρίς να δημιουργούνται deadlocks. Στο φάκελο περιέχεται makefile
για την άμεση μεταγλώττιση του προγράμματος.

Η διαμοιραζόμενη μνήμη είναι μία δομή που περιέχει τρεις μεταβλητές:

	-int value: Η μεταφερόμενη τιμή.
	-int counter: Το πλήθος των αναγνωστών που έχουν διαβάσει το τρέχον περιεχόμενο ως τώρα.
	-double timestamp: Η χρονοσφραγίδα της στιγμής εγγραφής της τρέχουσας τιμής.

Για την επίτευξη του συγχρονισμού, χρησιμοποιούνται 3 σετ σημαφόρων:

	* Ένα σετ n σημαφόρων, που αφορούν τους n διαφορετικούς αναγνώστες του διαμοιραζόμενου πίνακα - readid 
	Κάθε φορά που ένας θέλει να διαβάσει το επόμενο στοιχείο κατεβάζει το σημαφόρο που του αντιστοιχεί, με αποτέλεσμα να χρειαστεί
	να περιμένει σ'αυτόν, στην επόμενη απόπειρα ανάγνωσης, ώσπου ο Feeder να εγγράψει στη διαμοιραζόμενη μνήμη το επόμενο στοιχείο
	και να ανεβάσει τους σημαφόρους των αναγνωστών. Ετσί, βεβαιώνεται πως κάθε αναγνώστης, θα διαβάσει ακριβώς μια φορά κάθε
	στοιχείo που θα εγγραφεί στη μνήμη, με αποτέλεσμα να αναπαράγει σωστά τον αρχικό πίνακα.

	* Ένα σετ ενός σημαφόρου για τον Feeder - feedid
	Κάθε φορά που γράφει ένα νέο στοιχείο στη διαμοιραζόμενη μνήμη, κατεβάζει το σημαφόρο του. Έπειτα, οι αναγνώστες αυξάνουν σε
	κάθε ανάγνωση τον counter στη διαμοιραζόμενη μνήμη, με αποτέλεσμα, όταν ο τελευταίος του δώσει την τιμή n, που σηματοδοτεί πως
	όλοι οι αναγνώστες έχουν παραλάβει το τρέχον στοιχείο, ανεβάζει το σημαφόρο του Feeder, ώστε να εισάγει νέο στοιχείο στη μνήμη.

	* Ένα σετ ενός σημαφόρου για τους αναγνώστες - mutexid
	Ο σημαφόρος αυτός εξασφαλίζει τον αμοιβαίο αποκλεισμό στην πρόσβαση της διαμοιραζόμενης μνήμης και του αρχείου εξόδου, έτσι
	ώστε να είναι βέβαιο πως η τιμή του counter θα μεταβάλλεται ομαλά και πως οι εκτυπώσεις στο αρχείο εξόδου δε θα είναι πεπλεγμένες.


Για τη μέτρηση του χρόνου, με δεδομένο πως οι διεργασίες δεν έχουν ίδια στιγμή εκκίνησης, δεν έχει επιλεγεί η clock() όπως στην
πρώτη εργασία, αλλά η gettimeofday(), το πρότυπο της οποίας βρίσκεται στο <sys/time.h> σε συνδυασμό με τη δομή timeval. 

Για λόγους ευκολίας και αισθητικής ως προς το αρχείο εξόδου, έχει επιλεγεί οι αριθμοί του πίνακα να είναι ακέραιοι στο εύρος [1,100],
ώστε η ορθότητα των αποτελεσμάτων να "φαίνεται" και με οπτικά, χωρίς δυσκολία. Προφανώς, το πρόγραμμα δουλεύει εξ ίσου σωστά και με
μεγαλύτερο εύρος τιμών.

Ακολουθούν αποτελέσματα μέσης καθυστέρησης σε ms από ενδεικτικές εκτελέσεις για διάφορες τιμές των M και n:


										+-----+----------+----------+----------+
										| n\M |   3000   |   5000	|  10000   |
										+-----+----------+----------+----------+
										|  2  | 0.007334 | 0.005600 | 0.005850 |
										+-----+----------+----------+----------+	
										|  5  | 0.008000 | 0.006880 | 0.007180 |
										+-----+----------+----------+----------+
										| 10  | 0.030533 | 0.013700 | 0.018050 |
										+-----+----------+----------+----------+
										| 50  | 0.094933 | 0.101320 | 0.083580 |
										+-----+----------+----------+----------+
							
							
Οι τιμές του παραπάνω πίνακα, επιβεβαιώνουν όσα αναμένονταν και σε θεωρητικό επίπεδο.

Για σταθερό πλήθος διεργασιών, το μέγεθος του πίνακα δε φαίνεται να επηρεάζει το μέσο χρόνο αναμονής, πράγμα που δεν αποτελεί έκπληξη.
Αντίθετα, όσο αυξάνεται το πλήθος των διεργασιών, ο μέσος χρόνος αναμονής αυξάνεται ανάλογα. Η σχέση μεταξύ πλήθους διεργασιών και 
χρόνου αναμονής, μοιάζει να είναι γραμμική, καθώς η αύξηση του χρόνου παρουσιάζει αντίστοιχη αύξηση με αυτή των διεργασιών. 




